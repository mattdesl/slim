package slim.font;


import java.io.IOException;
import java.net.URL;

import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;

import slim.Image;
import slim.texture.Texture;
import slim.texture.Texture2D;
import de.matthiasmann.twl.utils.TextUtil;
import de.matthiasmann.twl.utils.XMLParser;

/**
 * A Bitmap Font class. Renders fonts generated by TWL Theme Editor's
 * "Create font" tool. Trimmed down for Slim by davedes.
 * 
 * @author Matthias Mann
 */
public class XMLBitmapFont {

    private static final int LOG2_PAGE_SIZE = 9;
    private static final int PAGE_SIZE = 1 << LOG2_PAGE_SIZE;
    private static final int PAGES = 0x10000 / PAGE_SIZE;

    public static class Glyph {
        public final short xoffset;
        public final short yoffset;
        public final short xadvance;
        byte[][] kerning;
        
        public final int x, y;
        public final int width, height;
        
        public Glyph(int x, int y, int width, int height, short xoffset, short yoffset, short xadvance) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.xoffset = xoffset;
            this.yoffset = yoffset;
            this.xadvance = xadvance;
        }
        
        public int getKerning(char ch) {
            if(kerning != null) {
                byte[] page = kerning[ch >>> LOG2_PAGE_SIZE];
                if(page != null) {
                    return page[ch & (PAGE_SIZE-1)];
                }
            }
            return 0;
        }
        
        public void setKerning(int ch, int value) {
            if(kerning == null) {
                kerning = new byte[PAGES][];
            }
            byte[] page = kerning[ch >>> LOG2_PAGE_SIZE];
            if(page == null) {
                kerning[ch >>> LOG2_PAGE_SIZE] = page = new byte[PAGE_SIZE];
            }
            page[ch & (PAGE_SIZE-1)] = (byte)value;
        }
    }

    private final Image page;
    private final Glyph[][] glyphs;
    private final int lineHeight;
    private final int baseLine;
    private final int spaceWidth;
    private final int ex;
    private final boolean proportional;

    public XMLBitmapFont(XMLParser xmlp, URL baseUrl) throws XmlPullParserException, IOException {
    	this(xmlp, baseUrl, null);
    }
    
    public XMLBitmapFont(XMLParser xmlp, URL baseUrl, Image page) throws XmlPullParserException, IOException {
        xmlp.require(XmlPullParser.START_TAG, null, "font");
        xmlp.nextTag();
        xmlp.require(XmlPullParser.START_TAG, null, "info");
        xmlp.ignoreOtherAttributes();
        xmlp.nextTag();
        xmlp.require(XmlPullParser.END_TAG, null, "info");
        xmlp.nextTag();
        xmlp.require(XmlPullParser.START_TAG, null, "common");
        lineHeight = xmlp.parseIntFromAttribute("lineHeight");
        baseLine = xmlp.parseIntFromAttribute("base");
        if(xmlp.parseIntFromAttribute("pages", 1) != 1) {
            throw new UnsupportedOperationException("multi page fonts not supported");
        }
        if(xmlp.parseIntFromAttribute("packed", 0) != 0) {
            throw new UnsupportedOperationException("packed fonts not supported");
        }
        xmlp.ignoreOtherAttributes();
        xmlp.nextTag();
        xmlp.require(XmlPullParser.END_TAG, null, "common");
        xmlp.nextTag();
        xmlp.require(XmlPullParser.START_TAG, null, "pages");
        xmlp.nextTag();
        xmlp.require(XmlPullParser.START_TAG, null, "page");
        int pageId = Integer.parseInt(xmlp.getAttributeValue(null, "id"));
        if(pageId != 0) {
            throw new UnsupportedOperationException("only page id 0 supported");
        }
        String textureName = xmlp.getAttributeValue(null, "file");
        
        if (page==null) { //if page is not specified, load from XML file
        	Texture2D pageTex = Texture2D.loadTexture(new URL(baseUrl, textureName), Texture.FILTER_NEAREST);
        	page = new Image(pageTex);
        }
        this.page = page;
        Texture2D texture = page.getTexture();
        
        xmlp.nextTag();
        xmlp.require(XmlPullParser.END_TAG, null, "page");
        xmlp.nextTag();
        xmlp.require(XmlPullParser.END_TAG, null, "pages");
        xmlp.nextTag();
        xmlp.require(XmlPullParser.START_TAG, null, "chars");
        xmlp.ignoreOtherAttributes();
        xmlp.nextTag();
        
        int firstXAdvance = Integer.MIN_VALUE;
        boolean prop = true;
        
        glyphs = new Glyph[PAGES][];
        while(!xmlp.isEndTag()) {
            xmlp.require(XmlPullParser.START_TAG, null, "char");
            int idx = xmlp.parseIntFromAttribute("id");
            int x = xmlp.parseIntFromAttribute("x");
            int y = xmlp.parseIntFromAttribute("y");
            int w = xmlp.parseIntFromAttribute("width");
            int h = xmlp.parseIntFromAttribute("height");
            if(xmlp.parseIntFromAttribute("page", 0) != 0) {
                throw xmlp.error("Multiple pages not supported");
            }
            int chnl = xmlp.parseIntFromAttribute("chnl", 0);
            short xoffset = Short.parseShort(xmlp.getAttributeNotNull("xoffset"));
            short yoffset = Short.parseShort(xmlp.getAttributeNotNull("yoffset"));
            short xadvance = Short.parseShort(xmlp.getAttributeNotNull("xadvance"));
            Glyph g = new Glyph(x, y, w, h, xoffset, yoffset, xadvance);
            addGlyph(idx, g);
            xmlp.nextTag();
            xmlp.require(XmlPullParser.END_TAG, null, "char");
            xmlp.nextTag();
            if(g.xadvance != firstXAdvance && g.xadvance > 0) {
                if(firstXAdvance == Integer.MIN_VALUE) {
                    firstXAdvance = g.xadvance;
                } else {
                    prop = false;
                }
            }
        }
        
        xmlp.require(XmlPullParser.END_TAG, null, "chars");
        xmlp.nextTag();
        if(xmlp.isStartTag()) {
            xmlp.require(XmlPullParser.START_TAG, null, "kernings");
            xmlp.ignoreOtherAttributes();
            xmlp.nextTag();
            while(!xmlp.isEndTag()) {
                xmlp.require(XmlPullParser.START_TAG, null, "kerning");
                int first = xmlp.parseIntFromAttribute("first");
                int second = xmlp.parseIntFromAttribute("second");
                int amount = xmlp.parseIntFromAttribute("amount");
                addKerning(first, second, amount);
                xmlp.nextTag();
                xmlp.require(XmlPullParser.END_TAG, null, "kerning");
                xmlp.nextTag();
            }
            xmlp.require(XmlPullParser.END_TAG, null, "kernings");
            xmlp.nextTag();
        }
        xmlp.require(XmlPullParser.END_TAG, null, "font");

        Glyph g = getGlyph(' ');
        spaceWidth = (g != null) ? g.xadvance + g.width : 1;

        Glyph gx = getGlyph('x');
        ex = (gx != null) ? gx.height : 1;
        
        proportional = prop;
    }
    
    public static XMLBitmapFont loadFont(URL url) throws IOException {
    	return loadFont(url, null);
    }

    public static XMLBitmapFont loadFont(URL url, Image pageImage) throws IOException {
        try {
            XMLParser xmlp = new XMLParser(url);
            try {
                xmlp.require(XmlPullParser.START_DOCUMENT, null, null);
                xmlp.nextTag();
                return new XMLBitmapFont(xmlp, url, pageImage);
            } finally {
                xmlp.close();
            }
        } catch (XmlPullParserException ex) {
            throw new IOException("error parsing font XML file "+url.getPath(), ex);
        }
    }

    public boolean isProportional() {
        return proportional;
    }
    
    public int getBaseLine() {
        return baseLine;
    }

    public int getLineHeight() {
        return lineHeight;
    }

    public int getSpaceWidth() {
        return spaceWidth;
    }

    public int getEM() {
        return lineHeight;
    }

    public int getEX() {
        return ex;
    }

    public void destroy() {
    	page.getTexture().destroy();
    }

    private void addGlyph(int idx, Glyph g) {
        if(idx <= Character.MAX_VALUE) {
            Glyph[] page = glyphs[idx >> LOG2_PAGE_SIZE];
            if(page == null) {
                glyphs[idx >> LOG2_PAGE_SIZE] = page = new Glyph[PAGE_SIZE];
            }
            page[idx & (PAGE_SIZE - 1)] = g;
        }
    }

    private void addKerning(int first, int second, int amount) {
        if(first >= 0 && first <= Character.MAX_VALUE &&
                second >= 0 && second <= Character.MAX_VALUE) {
            Glyph g = getGlyph((char)first);
            if(g != null) {
                g.setKerning(second, amount);
            }
        }
    }

    public final Glyph getGlyph(char ch) {
        Glyph[] page = glyphs[ch >> LOG2_PAGE_SIZE];
        if(page != null) {
            return page[ch & (PAGE_SIZE-1)];
        }
        return null;
    }
    
    public int computeTextWidth(CharSequence str, int start, int end) {
        int width = 0;
        Glyph lastGlyph = null;
        while(start < end) {
            lastGlyph = getGlyph(str.charAt(start++));
            if(lastGlyph != null) {
                width = lastGlyph.xadvance;
                break;
            }
        }
        while(start < end) {
            char ch = str.charAt(start++);
            Glyph g = getGlyph(ch);
            if(g != null) {
                width += lastGlyph.getKerning(ch);
                lastGlyph = g;
                width += g.xadvance;
            }
        }
        return width;
    }

    public int computeVisibleGlpyhs(CharSequence str, int start, int end, int availWidth) {
        int index = start;
        int width = 0;
        Glyph lastGlyph = null;
        for(; index < end ; index++) {
            char ch = str.charAt(index);
            Glyph g = getGlyph(ch);
            if(g != null) {
                if(lastGlyph != null) {
                    width += lastGlyph.getKerning(ch);
                }
                lastGlyph = g;
                if(proportional) {
                    width += g.xadvance;
                    if(width > availWidth) {
                        break;
                    }
                } else {
                    if(width + g.width + g.xoffset > availWidth) {
                        break;
                    }
                    width += g.xadvance;
                }
            }
        }
        return index - start;
    }
    
    /*
    protected int drawText(int x, int y, CharSequence str, int start, int end) {
        int startX = x;
        Glyph lastGlyph = null;
        while(start < end) {
            lastGlyph = getGlyph(str.charAt(start++));
            if(lastGlyph != null) {
                if(lastGlyph.width > 0) {
                    lastGlyph.draw(x, y);
                }
                x += lastGlyph.xadvance;
                break;
            }
        }
        while(start < end) {
            char ch = str.charAt(start++);
            Glyph g = getGlyph(ch);
            if(g != null) {
                x += lastGlyph.getKerning(ch);
                lastGlyph = g;
                if(g.width > 0) {
                    g.draw(x, y);
                }
                x += g.xadvance;
            }
        }
        return x - startX;
    }
    
    protected int drawMultiLineText(int x, int y, CharSequence str, int width, HAlignment align) {
        int start = 0;
        int numLines = 0;
        while(start < str.length()) {
            int lineEnd = TextUtil.indexOf(str, '\n', start);
            int xoff = 0;
            if(align != HAlignment.LEFT) {
                int lineWidth = computeTextWidth(str, start, lineEnd);
                xoff = width - lineWidth;
                if(align == HAlignment.CENTER) {
                    xoff /= 2;
                }
            }
            drawText(x + xoff, y, str, start, lineEnd);
            start = lineEnd + 1;
            y += lineHeight;
            numLines++;
        }
        return numLines;
    }

    public void computeMultiLineInfo(CharSequence str, int width, HAlignment align, int[] multiLineInfo) {
        int start = 0;
        int idx = 0;
        while(start < str.length()) {
            int lineEnd = TextUtil.indexOf(str, '\n', start);
            int lineWidth = computeTextWidth(str, start, lineEnd);
            int xoff = width - lineWidth;
            if(align == HAlignment.LEFT) {
                xoff = 0;
            } else if(align == HAlignment.CENTER) {
                xoff /= 2;
            }
            multiLineInfo[idx++] = (lineWidth << 16) | (xoff & 0xFFFF);
            start = lineEnd + 1;
        }
    }
    
    public void drawMultiLineLines(int x, int y, int[] multiLineInfo, int numLines) {
        beginLine();
        try {
            for(int i=0 ; i<numLines ; ++i) {
                int info = multiLineInfo[i];
                int xoff = x + (short)info;
                int lineWidth = info >>> 16;
                GL11.glVertex2i(xoff, y);
                GL11.glVertex2i(xoff + lineWidth, y);
                GL11.glVertex2i(xoff + lineWidth, y+1);
                GL11.glVertex2i(xoff, y+1);
                y += lineHeight;
            }
        } finally {
            endLine();
        }
    }*/
    
    public int computeMultiLineTextWidth(CharSequence str) {
        int start = 0;
        int width = 0;
        while(start < str.length()) {
            int lineEnd = indexOf(str, '\n', start, str.length());
            int lineWidth = computeTextWidth(str, start, lineEnd);
            width = Math.max(width, lineWidth);
            start = lineEnd + 1;
        }
        return width;
    }
    
    public Image getImage() {
    	return page;
    }
}